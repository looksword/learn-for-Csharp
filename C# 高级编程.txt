-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 特性（Attribute）
特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。
特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。
.Net 框架提供了两种类型的特性：预定义特性和自定义特性。
-----------------------------------------------------------------------------------------
规定特性（Attribute）

语法如下：
[attribute(positional_parameters, name_parameter = value, ...)]
element
特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。
positional_parameters 规定必需的信息，name_parameter 规定可选的信息。
-----------------------------------------------------------------------------------------
预定义特性（Attribute）

.Net 框架提供了三种预定义特性：
	AttributeUsage
	Conditional
	Obsolete

AttributeUsage
预定义特性 AttributeUsage 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。

语法如下：
[AttributeUsage(
   validon,//规定特性可被放置的语言元素。它是枚举器 AttributeTargets 的值的组合。默认值是 AttributeTargets.All。
   AllowMultiple=allowmultiple,//为该特性的 AllowMultiple 属性（property）提供一个布尔值。如果为 true，则该特性是多用的。默认值是 false（单用的）。
   Inherited=inherited//为该特性的 Inherited 属性（property）提供一个布尔值。如果为 true，则该特性可被派生类继承。默认值是 false（不被继承）。
)]

Conditional
这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符。
它会引起方法调用的条件编译，取决于指定的值，比如 Debug 或 Trace。例如，当调试代码时显示变量的值。

语法如下：
[Conditional(
   conditionalSymbol
)]

Obsolete
这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。

语法如下：
[Obsolete(
   message
)]
[Obsolete(
   message,//一个字符串，描述项目为什么过时以及该替代使用什么。
   iserror//是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。
)]
-----------------------------------------------------------------------------------------
创建自定义特性（Attribute）
.Net 框架允许创建自定义特性，用于存储声明性的信息，且可在运行时被检索。该信息根据设计标准和应用程序需要，可与任何目标元素相关。
创建并使用自定义特性包含四个步骤：
	声明自定义特性
	构建自定义特性
	在目标程序元素上应用自定义特性
	通过反射访问特性
最后一个步骤包含编写一个简单的程序来读取元数据以便查找各种符号。元数据是用于描述其他数据的数据和信息。该程序应使用反射来在运行时访问特性。

声明自定义特性
一个新的自定义特性应派生自 System.Attribute 类。

构建自定义特性
存储调试程序获得的信息。

应用自定义特性
通过把特性放置在紧接着它的目标之前，来应用该特性
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 反射（Reflection）
反射指程序可以访问、检测和修改它本身状态或行为的一种能力。
程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。
您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。 
优点
1.增加程序的灵活性、扩展性
2.降低耦合性，提高自适应能力
缺点
1.性能慢
2.复杂度高，易读性差
-----------------------------------------------------------------------------------------
反射（Reflection）的用途
	它允许在运行时查看特性（attribute）信息。
	它允许审查集合中的各种类型，以及实例化这些类型。
	它允许延迟绑定的方法和属性（property）。
	它允许在运行时创建新类型，然后使用这些类型执行一些任务。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 属性（Property）
属性（Property） 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 域（Field）。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 访问器（accessors） 让私有域的值可被读写或操作。
属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 访问器（accessors）。
-----------------------------------------------------------------------------------------
访问器（Accessors）
属性（Property）的访问器（accessor）包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。
-----------------------------------------------------------------------------------------
抽象属性（Abstract Properties）
抽象类可拥有抽象属性，这些属性应在派生类中被实现。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 索引器（Indexer）
索引器（Indexer） 允许一个对象可以像数组一样被索引。当您为类定义一个索引器时，该类的行为就会像一个 虚拟数组（virtual array） 一样。您可以使用数组访问运算符（[ ]）来访问该类的实例。

一维索引器的语法如下：

element-type this[int index] 
{
   // get 访问器
   get 
   {
      // 返回 index 指定的值
   }

   // set 访问器
   set 
   {
      // 设置 index 指定的值 
   }
}
-----------------------------------------------------------------------------------------
索引器（Indexer）的用途

索引器的行为的声明在某种程度上类似于属性（property）。就像属性（property），您可使用 get 和 set 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。
定义一个属性（property）包括提供属性名称。索引器定义的时候不带有名称，但带有 this 关键字，它指向对象实例。
-----------------------------------------------------------------------------------------
重载索引器（Indexer）

索引器（Indexer）可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型。没有必要让索引器必须是整型的。C# 允许索引器可以是其他类型，例如，字符串类型。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 委托（Delegate）
C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。
委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。
-----------------------------------------------------------------------------------------
声明委托（Delegate）
委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。

语法如下：

delegate <return type> <delegate-name> <parameter list>
-----------------------------------------------------------------------------------------
实例化委托（Delegate）

一旦声明了委托类型，委托对象必须使用 new 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 new 语句的参数就像方法调用一样书写，但是不带有参数。
-----------------------------------------------------------------------------------------
委托的多播（Multicasting of a Delegate）

委托对象可使用 "+" 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。"-" 运算符可用于从合并的委托中移除组件委托。 
使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 多播（multicasting），也叫组播。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 事件（Event）
事件（Event） 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。
C# 中使用事件机制实现线程间的通信。
-----------------------------------------------------------------------------------------
通过事件使用委托

事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 发布器（publisher） 类。其他接受该事件的类被称为 订阅器（subscriber） 类。事件使用 发布-订阅（publisher-subscriber） 模型。
发布器（publisher） 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。
订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。
-----------------------------------------------------------------------------------------
声明事件（Event）

在类的内部声明事件，首先必须声明该事件的委托类型。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 集合（Collection）
集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。
集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 Object 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。
-----------------------------------------------------------------------------------------
动态数组（ArrayList）

它代表了可被单独索引的对象的有序集合。
它基本上可以替代一个数组。但是，与数组不同的是，您可以使用索引在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。
-----------------------------------------------------------------------------------------
哈希表（Hashtable）

它使用键来访问集合中的元素。
当您使用键访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个键/值对。键用于访问集合中的项目。
-----------------------------------------------------------------------------------------
排序列表（SortedList）

它可以使用键和索引来访问列表中的项。 
排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。
-----------------------------------------------------------------------------------------
堆栈（Stack）

它代表了一个后进先出的对象集合。
当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为推入元素，当您从列表中移除一项时，称为弹出元素。
-----------------------------------------------------------------------------------------
队列（Queue）

它代表了一个先进先出的对象集合。
当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为入队，当您从列表中移除一项时，称为出队。
-----------------------------------------------------------------------------------------
点阵列（BitArray）

它代表了一个使用值 1 和 0 来表示的二进制数组。
当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用整型索引从点阵列集合中访问各项，索引从零开始。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 泛型（Generic）
泛型（Generic） 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。
您可以通过数据类型的替代参数编写类或方法的规范。当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理指定的数据类型。
-----------------------------------------------------------------------------------------
泛型（Generic）的特性
使用泛型是一种增强程序功能的技术，具体表现在以下几个方面：
	它有助于您最大限度地重用代码、保护类型的安全以及提高性能。
	您可以创建泛型集合类。.NET 框架类库在 System.Collections.Generic 命名空间中包含了一些新的泛型集合类。您可以使用这些泛型集合类来替代 System.Collections 中的集合类。
	您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。 
	您可以对泛型类进行约束以访问特定数据类型的方法。
	关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。
-----------------------------------------------------------------------------------------
泛型（Generic）方法

可以通过类型参数声明泛型方法。
-----------------------------------------------------------------------------------------
泛型（Generic）委托

可以通过类型参数定义泛型委托。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 匿名方法
我们已经提到过，委托是用于引用与其具有相同标签的方法。换句话说，您可以使用委托对象调用可由委托引用的方法。
匿名方法（Anonymous methods） 提供了一种传递代码块作为委托参数的技术。匿名方法是没有名称只有主体的方法。
在匿名方法中您不需要指定返回类型，它是从方法主体内的 return 语句推断的。
-----------------------------------------------------------------------------------------
编写匿名方法的语法

匿名方法是通过使用 delegate 关键字创建委托实例来声明的。
委托可以通过匿名方法调用，也可以通过命名方法调用，即，通过向委托对象传递方法参数。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 不安全代码
当一个代码块使用 unsafe 修饰符标记时，C# 允许在函数中使用指针变量。不安全代码或非托管代码是指使用了指针变量的代码块。
-----------------------------------------------------------------------------------------
指针变量

指针 是值为另一个变量的地址的变量，即，内存位置的直接地址。就像其他变量或常量，您必须在使用指针存储其他变量地址之前声明指针。
指针变量声明的一般形式为：
type* var-name;
在同一个声明中声明多个指针时，星号 * 仅与基础类型一起写入；而不是用作每个指针名称的前缀。
-----------------------------------------------------------------------------------------
int* p			p 是指向整数的指针。
double* p		p 是指向双精度数的指针。
float* p		p 是指向浮点数的指针。
int** p			p 是指向整数的指针的指针。
int*[] p		p 是指向整数的指针的一维数组。
char* p			p 是指向字符的指针。
void* p			p 是指向未知类型的指针。
-----------------------------------------------------------------------------------------
使用指针检索数据值

可以使用 ToString() 方法检索存储在指针变量所引用位置的数据。
-----------------------------------------------------------------------------------------
传递指针作为方法的参数

可以向方法传递指针变量作为方法的参数。
-----------------------------------------------------------------------------------------
使用指针访问数组元素

在 C# 中，数组名称和一个指向与数组数据具有相同数据类型的指针是不同的变量类型。例如，int *p 和 int[] p 是不同的类型。您可以增加指针变量 p，因为它在内存中不是固定的，但是数组地址在内存中是固定的，所以您不能增加数组 p。
因此，如果您需要使用指针变量访问数组数据，可以像我们通常在 C 或 C++ 中所做的那样，使用 fixed 关键字来固定指针。
-----------------------------------------------------------------------------------------
编译不安全代码

为了编译不安全代码，您必须切换到命令行编译器指定 /unsafe 命令行。

如果使用的是 Visual Studio IDE，那么需要在项目属性中启用不安全代码。
步骤如下：
	通过双击资源管理器（Solution Explorer）中的属性（properties）节点，打开项目属性（project properties）。
	点击 Build 标签页。
	选择选项"Allow unsafe code"。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
C# 多线程
线程 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。
线程是轻量级进程。一个使用线程的常见实例是现代操作系统中并行编程的实现。使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。
-----------------------------------------------------------------------------------------
线程生命周期

线程生命周期开始于 System.Threading.Thread 类的对象被创建时，结束于线程被终止或完成执行时。

线程生命周期中的各种状态：
	未启动状态：当线程实例被创建但 Start 方法未被调用时的状况。
	就绪状态：当线程准备好运行并等待 CPU 周期时的状况。
	不可运行状态：下面的几种情况下线程是不可运行的：
		已经调用 Sleep 方法
		已经调用 Wait 方法
		通过 I/O 操作阻塞
	死亡状态：当线程已完成执行或已中止时的状况。
-----------------------------------------------------------------------------------------
主线程

在 C# 中，System.Threading.Thread 类用于线程的工作。它允许创建并访问多线程应用程序中的单个线程。进程中第一个被执行的线程称为主线程。
当 C# 程序开始执行时，主线程自动创建。使用 Thread 类创建的线程被主线程的子线程调用。您可以使用 Thread 类的 CurrentThread 属性访问线程。
-----------------------------------------------------------------------------------------
Thread 类常用的属性和方法
-----------------------------------------------------------------------------------------
CurrentContext
获取线程正在其中执行的当前上下文。
-----------------------------------------------------------------------------------------
CurrentCulture
获取或设置当前线程的区域性。
-----------------------------------------------------------------------------------------
CurrentPrincipal
获取或设置线程的当前负责人（对基于角色的安全性而言）。
-----------------------------------------------------------------------------------------
CurrentThread
获取当前正在运行的线程。
-----------------------------------------------------------------------------------------
CurrentUICulture
获取或设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源。
-----------------------------------------------------------------------------------------
ExecutionContext
获取一个 ExecutionContext 对象，该对象包含有关当前线程的各种上下文的信息。
-----------------------------------------------------------------------------------------
IsAlive
获取一个值，该值指示当前线程的执行状态。
-----------------------------------------------------------------------------------------
IsBackground
获取或设置一个值，该值指示某个线程是否为后台线程。
-----------------------------------------------------------------------------------------
IsThreadPoolThread
获取一个值，该值指示线程是否属于托管线程池。
-----------------------------------------------------------------------------------------
ManagedThreadId
获取当前托管线程的唯一标识符。
-----------------------------------------------------------------------------------------
Name
获取或设置线程的名称。
-----------------------------------------------------------------------------------------
Priority
获取或设置一个值，该值指示线程的调度优先级。
-----------------------------------------------------------------------------------------
ThreadState
获取一个值，该值包含当前线程的状态。
-----------------------------------------------------------------------------------------
public void Abort()
在调用此方法的线程上引发 ThreadAbortException，以开始终止此线程的过程。调用此方法通常会终止线程。
-----------------------------------------------------------------------------------------
public static LocalDataStoreSlot AllocateDataSlot()
在所有的线程上分配未命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。
-----------------------------------------------------------------------------------------
public static LocalDataStoreSlot AllocateNamedDataSlot( string name) 
在所有线程上分配已命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。
-----------------------------------------------------------------------------------------
public static void BeginCriticalRegion()
通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常的影响可能会危害应用程序域中的其他任务。
-----------------------------------------------------------------------------------------
public static void BeginThreadAffinity()
通知主机托管代码将要执行依赖于当前物理操作系统线程的标识的指令。
-----------------------------------------------------------------------------------------
public static void EndCriticalRegion()
通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常仅影响当前任务。
-----------------------------------------------------------------------------------------
public static void EndThreadAffinity()
通知主机托管代码已执行完依赖于当前物理操作系统线程的标识的指令。
-----------------------------------------------------------------------------------------
public static void FreeNamedDataSlot(string name)
为进程中的所有线程消除名称与槽之间的关联。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。
-----------------------------------------------------------------------------------------
public static Object GetData( LocalDataStoreSlot slot ) 
在当前线程的当前域中从当前线程上指定的槽中检索值。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。
-----------------------------------------------------------------------------------------
public static AppDomain GetDomain()
返回当前线程正在其中运行的当前域。
-----------------------------------------------------------------------------------------
public static AppDomain GetDomainID()
返回唯一的应用程序域标识符。
-----------------------------------------------------------------------------------------
public static LocalDataStoreSlot GetNamedDataSlot( string name ) 
查找已命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。
-----------------------------------------------------------------------------------------
public void Interrupt()
中断处于 WaitSleepJoin 线程状态的线程。
-----------------------------------------------------------------------------------------
public void Join()
在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻塞调用线程，直到某个线程终止为止。此方法有不同的重载形式。
-----------------------------------------------------------------------------------------
public static void MemoryBarrier()
按如下方式同步内存存取：执行当前线程的处理器在对指令重新排序时，不能采用先执行 MemoryBarrier 调用之后的内存存取，再执行 MemoryBarrier 调用之前的内存存取的方式。
-----------------------------------------------------------------------------------------
public static void ResetAbort()
取消为当前线程请求的 Abort。
-----------------------------------------------------------------------------------------
public static void SetData( LocalDataStoreSlot slot, Object data ) 
在当前正在运行的线程上为此线程的当前域在指定槽中设置数据。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。
-----------------------------------------------------------------------------------------
public void Start()
开始一个线程。
-----------------------------------------------------------------------------------------
public static void Sleep( int millisecondsTimeout ) 
让线程暂停一段时间。
-----------------------------------------------------------------------------------------
public static void SpinWait( int iterations ) 
导致线程等待由 iterations 参数定义的时间量。
-----------------------------------------------------------------------------------------
public static byte VolatileRead( ref byte address )
public static double VolatileRead( ref double address )
public static int VolatileRead( ref int address )
public static Object VolatileRead( ref Object address ) 
读取字段值。无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。此方法有不同的重载形式。这里只给出了一些形式。
-----------------------------------------------------------------------------------------
public static void VolatileWrite( ref byte address, byte value )
public static void VolatileWrite( ref double address, double value )
public static void VolatileWrite( ref int address, int value )
public static void VolatileWrite( ref Object address, Object value ) 
立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。此方法有不同的重载形式。这里只给出了一些形式。
-----------------------------------------------------------------------------------------
public static bool Yield()
导致调用线程执行准备好在当前处理器上运行的另一个线程。由操作系统选择要执行的线程。
-----------------------------------------------------------------------------------------
创建线程

线程是通过扩展 Thread 类创建的。扩展的 Thread 类调用 Start() 方法来开始子线程的执行。
-----------------------------------------------------------------------------------------
管理线程

Thread 类提供了各种管理线程的方法。
-----------------------------------------------------------------------------------------
销毁线程

Abort() 方法用于销毁线程。
通过抛出 threadabortexception 在运行时中止线程。这个异常不能被捕获，如果有 finally 块，控制会被送至 finally 块。
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------