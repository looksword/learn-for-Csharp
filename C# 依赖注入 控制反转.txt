-------------------------------------------------------------------------------------依赖
当一个类需要另一个类协作来完成工作的时候就产生了依赖。

在AccountController这个控制器需要完成和用户相关的注册、登录 等事情。
其中的登录由EF结合Idnetity来完成，所以封装了一个EFLoginService。
这里AccountController就有一个ILoginService的依赖。



-------------------------------------------------------------------------------------注入
注入体现的是一个IOC（控制反转的的思想）。

正转：
private ILoginService<ApplicationUser> _loginService;//AccountController自己来实例化需要的依赖。
public AccountController()
{
  _loginService = new EFLoginService()
}

注入：
public AccountController(ILoginService<ApplicationUser> loginService)
{
  _loginService = loginService;
}
//把依赖的创建丢给其它人，自己只负责使用，其它人丢给你依赖的这个过程理解为注入。



-------------------------------------------------------------------------------------容器
依赖太多，需要一个地方统一管理系统中所有的依赖，容器诞生了。

容器负责两件事情：
1.绑定服务与实例之间的关系
2.获取实例，并对实例进行管理（创建与销毁）



-------------------------------------------------------------------------------------依赖注入的类别
1.Setter注入
Setter注入（Setter Injection）是指在客户类中，设置一个服务类接口类型的数据成员，并设置一个Set方法作为注入点，
这个Set方法接受一个具体的服务类实例为参数，并将它赋给服务类接口类型的数据成员。

2.构造注入
通过客户类的构造函数，向客户类注入服务类实例。
构造注入（Constructor Injection）是指在客户类中，设置一个服务类接口类型的数据成员，并以构造函数为注入点，
这个构造函数接受一个具体的服务类实例为参数，并将它赋给服务类接口类型的数据成员。

3. 依赖获取
依赖获取（Dependency Locate）是指在系统中提供一个获取点，客户类仍然依赖服务类的接口。当客户类需要服务类时，
从获取点主动取得指定的服务类，具体的服务类类型由获取点的配置决定。

反射与依赖注入
有一种方法，不是通过“new”，而是通过类的名字来实例化对象，那么我们只要将类的名字作为配置项，
就可以实现在不修改代码的情况下，加载未来才出现的类。
反射不仅可以与Dependency Locate结合，也可以与Setter Injection与Construtor Injection结合。
反射机制的引入，降低了依赖注入结构的复杂度，使得依赖注入彻底符合OCP，
并为通用依赖注入框架（如Spring.NET中的IoC部分、Unity等）的设计提供了可能性。







